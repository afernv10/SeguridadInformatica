import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;

public class HuffmanBinario {

	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		double[] probs = {0.3, 0.2, 0.1, 0.1, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05};
		String[] idsPosicion = new String[probs.length];
		// crear los ids de posicion
		for( int pos = 0; pos < idsPosicion.length; pos++) {
			int p =(pos+1);
			idsPosicion[pos] = Integer.toString(p);
		}
		
		
		// Priority queue
		// TODO mirar si es de min-heap o max-heap
        PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(probs.length, new ComparadorProbs()); 
        // NO VA ESTO
        for (int i = 0; i < probs.length; i++) { 
  
            // creating a huffman node object 
            // and adding it to the priority-queue. 
            HuffmanNode hn = new HuffmanNode(); 
  
            hn.setPosicion(idsPosicion[i]); 
            hn.setValor(probs[i]); 
  
            hn.setLeft(null);
            hn.setRight(null); 
  
            // add functions adds 
            // the huffman node to the queue. 
            q.add(hn); 
        }
		
        HuffmanNode root = null;

		while (q.size() > 1) {

			HuffmanNode x = q.peek();
			q.poll();

			// second min extarct.
			HuffmanNode y = q.peek();
			q.poll();

			// new node f which is equal
			HuffmanNode f = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			f.setValor(x.getValor() + y.getValor());
			f.setPosicion("-");

			// first extracted node as left child.
			f.left = x;

			// second extracted node as the right child.
			f.right = y;

			// marking the f node as the root node.
			root = f;

			// add this node to the priority-queue.
			q.add(f);

		}

		printCode(root, "");

	}
	
	// recursive function to print the 
    // huffman-code through the tree traversal. 
    // Here s is the huffman - code generated. 
    public static void printCode(HuffmanNode root, String s) 
    { 
  
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 
        if (root.left == null && root.right == null /*&& Character.isDigit(root.getPosicion())*/) { 
  
            // c is the character in the node 
            System.out.println(root.getPosicion() + ":" + s); 
  
            return; 
        } 
  
        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
  
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.getLeft(), s + "1"); 
        printCode(root.getRight(), s + "0"); 
    } 

}

class ComparadorProbs implements Comparator<HuffmanNode> {

	@Override
	public int compare(HuffmanNode o1, HuffmanNode o2) {
		// TODO Auto-generated method stub
		
		if (o1.getValor() < o2.getValor()) return -1;
        if (o1.getValor() > o2.getValor()) return 1;
        //if(Math.abs(o1.getValor()-o2.getValor()) < ERR) return 0;
        return 0;
		
		//return Double.compare(o1.getValor(), o2.getValor());
	}

}
